
node ('master') {

    env.JAVA_HOME="${tool 'openjdk-9'}"
    env.MVN_HOME="${tool 'maven-3.6.3'}"
    env.PATH="${env.JAVA_HOME}/bin:${env.MVN_HOME}/bin:${env.PATH}"
	env.BUILD_IMAGE="agaveplatform/maven:3.6.3-proto"

	// Send a message indicating the start of the build. We record the thread and add it to the environment
	// so we thread all future messages
    def slackResponse = slackSend(color: "good", message: "Started Agave Science API build <${env.BUILD_URL}|${env.BUILD_DISPLAY_NAME}>")
    env.SLACK_THREAD_ID=slackResponse.threadId
    
    checkoutSource()
    // build()
    // unitTest()
    integrationTest()
//     buildImages()
//     helmDeploy()
    slackSend channel: env.SLACK_THREAD_ID, color: "green", message: "Successful build of Agave Science APIs. Log availabl at <${env.BUILD_URL}|here>."
}

def isPRMergeBuild() {
    return (env.BRANCH_NAME ==~ /^PR-\d+$/)
}

// Returs the short commit hash for the current checkout. We use this approach to avoid compatibility issues with the
// response from the GitSCM plugin
//
// @returns short 7 digit git commit hash
def shortCommitHash() {
	return sh(returnStdout: true, script: "git log -n 1 --pretty=format:'%h'").trim()
}

// Returns the full commit hash for the current checkout. We use this approach to avoid compatibility issues with the
// response from the GitSCM plugin
//
// @returns full git commit hash
def commitHash() {
	return sh(returnStdout: true, script: "git rev-parse HEAD").trim()
}

def checkoutSource () {
    stage('Checkout code') {
		context="continuous-integration/jenkins/"
		context += isPRMergeBuild()?"pr-merge/checkout":"branch/checkout"
		checkout([$class: 'GitSCM', branches: [[name: '*/2.2.27']], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: 'deardooley-github-access-token', url: 'https://deardooley@github.com/agaveplatform/science-apis.git']]])
		//    setBuildStatus ("${context}", 'Checking out completed', 'SUCCESS')

		// set the commit hash and short hash for use in this build
		env.GIT_COMMIT=commitHash()
		env.GIT_SHORT_HASH=shortCommitHash()

		slackSend channel: env.SLACK_THREAD_ID, color: "green", message: "Checked out commit ${env.GIT_SHORT_HASH} from branch ${env.GIT_BRANCH}."
	}
}

def build () {
    stage('Build Source') {
		//def MAVEN_CMD = "/usr/bin/docker run -i --rm -w $(pwd) -v ${env.WORKSPACE}:${env.WORKSPACE} -v ${env.HOME}/.m2:/root/.m2  -v /var/run/docker.sock:/var/run/docker.sock --net host agaveplatform/maven:3.6.3-proto mvn -Dstyle.color=never "
        def MAVEN_CMD = "mvn -Dstyle.color=never "
		try {
			sh "${MAVEN_CMD} -T 1.0C -P agave,dev clean compile "
			slackSend channel: env.SLACK_THREAD_ID, color: "green", message: "Source compilation complete."
		}
		catch (err) {
			slackSend channel: env.SLACK_THREAD_ID, color: "danger", message: "Source compilation failed. Terminating build"
			throw err
		}
	}
}

def unitTest() {
    	stage ('Unit Tests') {
			//def MAVEN_CMD = "/usr/bin/docker run -i --rm -w ${env.WORKSPACE} -v ${env.WORKSPACE}:${env.WORKSPACE} -v ${env.HOME}/.m2:/root/.m2  -v /var/run/docker.sock:/var/run/docker.sock --net=host agaveplatform/maven:3.6.3-proto mvn -Dstyle.color=never "
			def MAVEN_CMD = "mvn -Dstyle.color=never "

			try {
				sh "${MAVEN_CMD} -T 1.0C -P agave,dev install"

				// collect unit test output for report and archiving
				step([$class: 'JUnitResultArchiver', testResults: '**/target/surefire-reports/TEST-*.xml'])

				slackSend channel: env.SLACK_THREAD_ID, color: "green", message: "Unit tests complete."
			}
			catch (err) {
				slackSend channel: env.SLACK_THREAD_ID, color: "danger", message: "Unit tests failed. Terminating build."
				throw err
			}
		}
	}
}

def integrationTest() {
    	stage ('Integration Tests') {
        withCredentials([usernamePassword(credentialsId: 'docker-hub-login', passwordVariable: 'DOCKER_REGISTRY_PASS', usernameVariable: 'DOCKER_REGISTRY_USER')]) {
			//def MAVEN_CMD = "/usr/bin/docker run -i --rm -w ${env.WORKSPACE} -v ${env.WORKSPACE}:${env.WORKSPACE} -v ${env.HOME}/.m2:/root/.m2 -v ${env.HOME}/.docker:/root/.docker -v /usr/bin/docker:/usr/bin/docker -v /var/run/docker.sock:/var/run/docker.sock --net=host agaveplatform/maven:3.6.3-proto mvn -Dstyle.color=never "
            def MAVEN_CMD = "mvn -Dstyle.color=never -P agave,integration-test verify -Dawait-maven-plugin.initialWait=15000 -Ddocker-compose-plugin.awaitDuration=10 -Dskip.post-integration.pause=false "
            
            def DOCKER_REGISTRY_URL = ''
            def DOCKER_REGISTRY_ORG = 'agaveplatform'
            
			try {
				// login to the docker registry
    			sh "docker login -u ${DOCKER_REGISTRY_USER} -p ${DOCKER_REGISTRY_PASS} ${DOCKER_REGISTRY_URL}"

                stage ('Migrations') {
                    clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl agave-migrations "
                }
                
                stage ('Protobuf Java Stubs') {
                	clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl :protos-java "
                }
                
                stage ('sftp-relay') {
                	clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl :sftp-relay "
                }
                
                stage ('Common Core') {
                	clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl :common-core "
                }
                
                stage ('Common API') {
                	clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl :common-api "
                }
                
                stage ('Common Legacy API') {
                    clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl :common-legacy-api "
                }
                
                stage ('Postits API') {
                	clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl :postits-api "
                }
                
                stage ('Usage API') {
                	clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl :usage-api "
                	clearCurrentContainers()
                }
                
                stage ('Tenants API') {
                	clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl :tenants-api "
                }
                
                stage ('Logging API') {
                	clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl :logging-api "
                }
                
                stage ('Notifications Core') {
                	clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl :notifications-core "
                }
                
                stage ('Notifications API') {
                	clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl :notifications-api "
                }
                
                stage ('Profiles Core') {
                	clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl :profiles-core "
                }
                
                stage ('Profiles API') {
                	clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl :profiles-api "
                }
                
                stage ('Metadata Core') {
                	clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl :metadata-core "
                }
                
                stage ('Metadata API') {
                	clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl :metadata-api "
                }
                
                stage ('Systems Core') {
                	clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl :systems-core "
                }
                
                stage ('Systems API') {
                	clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl :systems-api "
                	clearCurrentContainers()
                }
                
                stage ('Monitors Core') {
                	clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl :monitors-core "
                	clearCurrentContainers()
                }
                
                stage ('Monitors API') {
                	clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl :monitors-api "
                	clearCurrentContainers()
                }
                
                stage ('Files Core') {
                	clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl :files-core "
                	clearCurrentContainers()
                }
                
                stage ('Files API') {
                	clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl :files-api "
                }
                
                stage ('Apps Core') {
                	clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl :apps-core "
                }
                
                stage ('Apps API') {
                	clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl :apps-api "
                }
                
                stage ('Jobs Core') {
                	clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl :jobs-core "
                }
                
                stage ('Jobs API') {
                	clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl :jobs-api "
                }
                
                stage ('Tags Core') {
                	clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl :tags-core "
                }
                
                stage ('Tags API') {
                	clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl :tags-api "
                }
                
                stage ('Realtime Core') {
                	clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl :realtime-core "
                }
                
                stage ('Realtime API') {
                	clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl :realtime-api "
                }
                
                stage ('Stats API') {
                	clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl :stats-api "
                }
                
                stage ('Uuids API') {
                	clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl :uuids-api "
                }
                
                stage ('Apidocs API') {
                	clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl :apidocs-api "
                }
                
    // 			sh "${MAVEN_CMD} -P agave,integration-test verify -Dawait-maven-plugin.initialWait=15000 -Ddocker-compose-plugin.awaitDuration=10 -Dskip.post-integration.pause=false "

    			step([$class: 'JUnitResultArchiver', testResults: '**/target/failsafe-reports/TEST-*.xml'])

    			slackSend channel: env.SLACK_THREAD_ID, color: "green", message: "Integration tests completed successfully. Log availabl at <${env.BUILD_URL}|here>."

			}
			catch (err) {

				clearCurrentContainers()

				slackSend channel: env.SLACK_THREAD_ID, color: "danger", message: "Integration tests failed. Terminating build."

				throw err
			}

		}
	}
}

// Remove existing containers to avoid conflicts from failed builds
def clearCurrentContainers() {

    echo "Stopping existing docker containers"

	sh "docker ps -a --format '{{.Names}}' | grep -v traefik_traefik_  | xargs --no-run-if-empty docker stop"

	echo "Removing existing containers"

	sh "docker ps -a --format '{{.Names}}' | grep -v traefik_traefik_  | xargs --no-run-if-empty docker rm -f"
}


def coverage() {
    stage ('Code Coverage Analysis') {
		withCredentials([file(credentialsId: 'maven-third-party-settings-file', variable: 'MAVEN_THIRD_PARTY_SETTINGS_FILE'),
						 usernamePassword(credentialsId: 'docker-hub-login', passwordVariable: 'DOCKER_REGISTRY_PASS', usernameVariable: 'DOCKER_REGISTRY_USER')]) {

            def DOCKER_REGISTRY_URL = ''
            def DOCKER_REGISTRY_ORG = 'agaveplatform'

			//def MAVEN_CMD = "docker run -i --rm -v ${env.MAVEN_THIRD_PARTY_SETTINGS_FILE}:/root/settings.xml -v ${env.WORKSPACE}:/sources -v ${env.HOME}/.m2:/root/.m2  -v /usr/bin/docker:/usr/bin/docker -v /var/run/docker.sock:/var/run/docker.sock --net=host agaveplatform/maven:3.6.3-proto mvn --settings=/root/settings.xml"
            def MAVEN_CMD = "mvn -Dstyle.color=never --settings=${env.MAVEN_THIRD_PARTY_SETTINGS_FILE} "
			try {
			    // login to the docker registry
			    sh "docker login -u ${DOCKER_REGISTRY_USER} -p ${DOCKER_REGISTRY_PASS} ${DOCKER_REGISTRY_URL}"


				sh "${MAVEN_CMD} -P agave,integration-test,coverage verify"
				step( [$class: 'JacocoPublisher', exclusionPattern: '**/*Exception*,**/*Configuration*,**/ApiApplication*,**/*Test*'])
			}
			catch (err) {
				slackSend color: "red", message: "Failed running third-party integration tests. Failed build is on display at <${env.BUILD_URL}|here>."
				throw err
			}
		}
	}
}

// handles clean build and push of docker images for the current branch and revision
def buildImages() {
    clearExistingBuildImages()
    buildCurrentReleaseImages()
    // publishImages()
}

// clears out existing revision and branch images
def clearExistingBuildImages() {
    stage ("Clean Docker Images") {
		def revision = getRepoSlug()
		def branch = getBranch()

		// remove existing revision images
		sh "./dockerbuild.sh -c -t ${DOCKER_REGISTRY_URL}/${DOCKER_REGISTRY_ORG} -v ${revision}"
		// remove existing branch images
		sh "./dockerbuild.sh -c -t ${DOCKER_REGISTRY_URL}/${DOCKER_REGISTRY_ORG} -v ${branch}"
	}
}

// builds new images tagged with the short revision commit hash and the branch name
def buildCurrentReleaseImages() {
    stage ("Build Docker Images") {

		// load docker credentials so we don't get bitten by the docker registry rate limiting policy
		withCredentials([usernamePassword(credentialsId: 'docker-hub-login', passwordVariable: 'DOCKER_REGISTRY_PASS', usernameVariable: 'DOCKER_REGISTRY_USER')]) {
			def revision = getRepoSlug()
			def branch = getBranch()

	//        // remove existing revision images
	//        sh "./dockerbuild.sh -c -t ${DOCKER_REGISTRY_URL}/${DOCKER_REGISTRY_ORG} -v ${revision}"
	//        // remove existing branch images
	//        sh "./dockerbuild.sh -c -t ${DOCKER_REGISTRY_URL}/${DOCKER_REGISTRY_ORG} -v ${branch}"

			// login to the docker registry
			sh "docker login -u ${DOCKER_REGISTRY_USER} -p ${DOCKER_REGISTRY_PASS} ${DOCKER_REGISTRY_URL}"

			// build images from current revision
			sh "./dockerbuild.sh -b -t ${DOCKER_REGISTRY_URL}/${DOCKER_REGISTRY_ORG} -v ${revision}"

			// tag revision images with branch name
			sh "./dockerbuild.sh -r -s ${DOCKER_REGISTRY_URL}/${DOCKER_REGISTRY_ORG} -w ${revision} -t ${DOCKER_REGISTRY_URL}/${DOCKER_REGISTRY_ORG} -v ${branch}"
		}
	}
}

// push images to the configured docker registry
def publishImages() {
	stage('Push Images') {
		withCredentials([usernamePassword(credentialsId: 'docker-hub-login', passwordVariable: 'DOCKER_REGISTRY_PASS', usernameVariable: 'DOCKER_REGISTRY_USER')]) {
			def revision = getRepoSlug()
			def branch = getBranch()
			stage "Push Docker Images"
			// login to the docker registry
			sh "docker login -u ${DOCKER_REGISTRY_USER} -p ${DOCKER_REGISTRY_PASS} ${DOCKER_REGISTRY_URL}"
			// push revision images to repo
			sh "./dockerbuild.sh -p -t ${DOCKER_REGISTRY_URL}/${DOCKER_REGISTRY_ORG} -v ${revision}"
			// push branch images to repo
			sh "./dockerbuild.sh -p -t ${DOCKER_REGISTRY_URL}/${DOCKER_REGISTRY_ORG} -v ${branch}"
		}
	}
}

def preview() {
    buildImages()
    deployToStage(branch)
}

// def preProduction() {
//     switchSnapshotBuildToRelease()
//     herokuApp = "${env.HEROKU_PREPRODUCTION}"
//     deployToStage("preproduction", herokuApp)
//     buildAndPublishToArtifactory()
// }
//
// def manualPromotion() {
//   stage 'Manual Promotion'
//     // we need a first milestone step so that all jobs entering this stage are tracked an can be aborted if needed
//     milestone 1
//     // time out manual approval after ten minutes
//     timeout(time: 10, unit: 'MINUTES') {
//         input message: "Does Pre-Production look good?"
//     }
//     // this will kill any job which is still in the input step
//     milestone 2
// }

// def production() {
//     herokuApp = "${env.HEROKU_PRODUCTION}"
//     step([$class: 'ArtifactArchiver', artifacts: '**/target/*.jar', fingerprint: true])
//     deployToStage("production", herokuApp)
//     def version = getCurrentHerokuReleaseVersion("${env.HEROKU_PRODUCTION}")
//     def createdAt = getCurrentHerokuReleaseDate("${env.HEROKU_PRODUCTION}", version)
//     echo "Release version: ${version}"
//     createRelease(version, createdAt)
//
//     stage ("Promote in Artifactory") {
//         promoteBuildInArtifactory()
//         // distributeBuildToBinTray()
//     }
// }

// void createRelease(tagName, createdAt) {
//     withCredentials([[$class: 'StringBinding', credentialsId: 'GITHUB_TOKEN', variable: 'GITHUB_TOKEN']]) {
//         def body = "**Created at:** ${createdAt}\n**Deployment job:** [${env.BUILD_NUMBER}](${env.BUILD_URL})\n**Environment:** [${env.HEROKU_PRODUCTION}](https://dashboard.heroku.com/apps/${env.HEROKU_PRODUCTION})"
//         def payload = groovy.json.JsonOutput.toJson(["tag_name": "v${tagName}", "name": "${env.HEROKU_PRODUCTION} - v${tagName}", "body": "${body}"])
//         def apiUrl = "https://octodemo.com/api/v3/repos/${getRepoSlug()}/releases"
//         def response = sh(returnStdout: true, script: "curl -s -H \"Authorization: Token ${env.GITHUB_TOKEN}\" -H \"Accept: application/json\" -H \"Content-type: application/json\" -X POST -d '${payload}' ${apiUrl}").trim()
//     }
// }
//
// def deployToStage(stageName, herokuApp) {
//     stage name: "Deploy to ${stageName}", concurrency: 1
//     id = createDeployment(getBranch(), "${stageName}", "Deploying branch to ${stageName}")
//     echo "Deployment ID for ${stageName}: ${id}"
//     if (id != null) {
//         setDeploymentStatus(id, "pending", "https://${herokuApp}.herokuapp.com/", "Pending deployment to ${stageName}");
//         herokuDeploy "${herokuApp}"
//         setDeploymentStatus(id, "success", "https://${herokuApp}.herokuapp.com/", "Successfully deployed to ${stageName}");
//     }
// }

// Deploys core services to the current branch namespace using the given `agaveVersion` tag.
def helmDeploy (agaveVersion) {
    stage('Deploy core-services') {
        def helmRelease = getCurrentHelmRelease()
        withCredentials([file(credentialsId: 'agave-kubectl-config', variable: 'KUBECONFIG_FILE_PATH')]) {

            if (helmRelease == null) {
                sh "helm3 --kubeconfig \"${env.KUBECONFIG_FILE_PATH}\" install --namespace ${env.BRANCH} --set agave.version=${agaveVersion} core-services agave/core-service'"
            } else {
                sh "helm3 --kubeconfig \"${env.KUBECONFIG_FILE_PATH}\" upgrade --namespace ${env.BRANCH} --set agave.version=${agaveVersion} core-services agave/core-service'"
            }
        }
    }
}

//
//def switchSnapshotBuildToRelease() {
//    def descriptor = Artifactory.mavenDescriptor()
//    descriptor.version = '1.0.0'
//    descriptor.pomFile = 'pom.xml'
//    descriptor.transform()
//}
//
//def buildAndPublishToArtifactory() {
//        def rtMaven = Artifactory.newMavenBuild()
//        rtMaven.tool = null
//        withEnv(["MAVEN_HOME=/usr/share/maven"]) {
//           rtMaven.deployer releaseRepo:'libs-release-local', snapshotRepo:'libs-snapshot-local', server: server
//           rtMaven.resolver releaseRepo:'libs-release', snapshotRepo:'libs-snapshot', server: server
//           rtMaven.run pom: 'pom.xml', goals: 'install', buildInfo: buildInfo
//           server.publishBuildInfo buildInfo
//        }
//}
//
//def promoteBuildInArtifactory() {
//        def promotionConfig = [
//            // Mandatory parameters
//            'buildName'          : buildInfo.name,
//            'buildNumber'        : buildInfo.number,
//            'targetRepo'         : 'libs-prod-local',
//
//            // Optional parameters
//            'comment'            : 'deploying to production',
//            'sourceRepo'         : 'libs-release-local',
//            'status'             : 'Released',
//            'includeDependencies': false,
//            'copy'               : true,
//            // 'failFast' is true by default.
//            // Set it to false, if you don't want the promotion to abort upon receiving the first error.
//            'failFast'           : true
//        ]
//
//        // Promote build
//        server.promote promotionConfig
//}
//
//def distributeBuildToBinTray() {
//        def distributionConfig = [
//            // Mandatory parameters
//            'buildName'             : buildInfo.name,
//            'buildNumber'           : buildInfo.number,
//            'targetRepo'            : 'reading-time-dist',
//            // Optional parameters
//            //'publish'               : true, // Default: true. If true, artifacts are published when deployed to Bintray.
//            'overrideExistingFiles' : true, // Default: false. If true, Artifactory overwrites builds already existing in the target path in Bintray.
//            //'gpgPassphrase'         : 'passphrase', // If specified, Artifactory will GPG sign the build deployed to Bintray and apply the specified passphrase.
//            //'async'                 : false, // Default: false. If true, the build will be distributed asynchronously. Errors and warnings may be viewed in the Artifactory log.
//            //"sourceRepos"           : ["yum-local"], // An array of local repositories from which build artifacts should be collected.
//            //'dryRun'                : false, // Default: false. If true, distribution is only simulated. No files are actually moved.
//        ]
//        server.distribute distributionConfig
//}

//def mvn(args) {
//    withMaven(
//        // mavenSettingsConfig: '0e94d6c3-b431-434f-a201-7d7cda7180cb'
//
//        //mavenLocalRepo: '/tmp/m2'
//        ) {
//
//      // Run the maven build
//      sh "mvn $args -Dmaven.test.failure.ignore -Dmaven.repo.local=/cache"
//     }
//}

def getRepoSlug() {
    tokens = "${env.JOB_NAME}".tokenize('/')
    org = tokens[tokens.size()-3]
    repo = tokens[tokens.size()-2]
    return "${org}/${repo}"
}

def getBranch() {
    tokens = "${env.JOB_NAME}".tokenize('/')
    branch = tokens[tokens.size()-1]
    return "${branch}"
}

// update helm chart with latest release
def updateHelmChart(ref, environment, description) {
    stage('Update Helm Chart') {
    	withCredentials([
    			[$class: 'StringBinding', credentialsId: 'HELM_REPO_USERNAME', variable: 'HELM_REPO_USERNAME'],
    			[$class: 'StringBinding', credentialsId: 'HELM_REPO_PASSWORD', variable: 'HELM_REPO_PASSWORD']]) {
    		step: "Package chart"
    			def packagedChartPath = sh(returnStdout: true, script: 'helm3 package charts/core-services | sed -E "s/.*\\:(.*)/\\1/"').trim()
    		step: "Push chart to chartmuseum"
    			sh "curl -u '${env.HELM_REPO_USERNAME}:${env.HELM_REPO_PASSWORD}' -XPOST https://helm.agaveplatform.org/api/charts --data-binary @${packagedChartPath}"
    	}
    }
}

// Deploy updated chart
def createDeployment(ref, environment, description) {
    withCredentials([[$class: 'StringBinding', credentialsId: 'GITHUB_TOKEN', variable: 'GITHUB_TOKEN']]) {
            def payload = groovy.json.JsonOutput.toJson(["ref": "${ref}", "description": "${description}", "environment": "${environment}", "required_contexts": []])
        def apiUrl = "https://octodemo.com/api/v3/repos/${getRepoSlug()}/deployments"
        def response = sh(returnStdout: true, script: "curl -s -H \"Authorization: Token ${env.GITHUB_TOKEN}\" -H \"Accept: application/json\" -H \"Content-type: application/json\" -X POST -d '${payload}' ${apiUrl}").trim()
        def jsonSlurper = new groovy.json.JsonSlurper()
        def data = jsonSlurper.parseText("${response}")
        return data.id
    }
}

// // Update github deployment status
// void setDeploymentStatus(deploymentId, state, targetUrl, description) {
//     withCredentials([[$class: 'StringBinding', credentialsId: 'GITHUB_TOKEN', variable: 'GITHUB_TOKEN']]) {
//         def payload = groovy.json.JsonOutput.toJson(["state": "${state}", "target_url": "${targetUrl}", "description": "${description}"])
//         def apiUrl = "https://octodemo.com/api/v3/repos/${getRepoSlug()}/deployments/${deploymentId}/statuses"
//         def response = sh(returnStdout: true, script: "curl -s -H \"Authorization: Token ${env.GITHUB_TOKEN}\" -H \"Accept: application/json\" -H \"Content-type: application/json\" -X POST -d '${payload}' ${apiUrl}").trim()
//     }
// }

// Update github build status
void setGithubBuildStatus(context, message, state) {
  step([
      $class: "GitHubCommitStatusSetter",
      contextSource: [$class: "ManuallyEnteredCommitContextSource", context: context],
      errorHandlers: [[$class: "ChangingBuildStatusErrorHandler", result: "UNSTABLE"]],
      reposSource: [$class: "ManuallyEnteredRepositorySource", url: "https://github.com/agaveplatform/science-apis"],
      statusResultSource: [ $class: "ConditionalStatusResultSource", results: [[$class: "AnyBuildResult", message: message, state: state]] ]
  ]);
}

// Fetches the current helm chart release version from the kubernetes server
def getCurrentHelmRelease(app) {
	withCredentials([file(credentialsId: 'agave-kubectl-config', variable: 'KUBECONFIG_FILE_PATH')]) {
        def response = sh(returnStdout: true, script: "helm3 --kubeconfig \"${env.KUBECONFIG_FILE_PATH}\" list --namespace ${environment} --filter 'agave-core' -o json").trim()
        if (response != null || response != '[]') {
            def jsonSlurper = new groovy.json.JsonSlurper()
            def data = jsonSlurper.parseText("${response}")
            return data[0]
        } else {
            return null
        }
    }
}











